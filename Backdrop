import React, { useCallback, useState, useRef, useEffect } from "react";
// ... (imports)

// You can REMOVE the useEffect with the document.addEventListener,
// as the backdrop div will handle the click outside.

export const ReactFlowWrapper = () => {
  // ... (your existing state and hooks)

  const [deleteButton, setDeleteButton] = useState({ /* ... */ });
  const [nodeContextMenu, setNodeContextMenu] = useState({ /* ... */ });
  const [edgeMenu, setEdgeMenu] = useState({ /* ... */ });

  // Add handlers to close the menus
  const closeDeleteButton = useCallback(() => {
    setDeleteButton({ visible: false, x: 0, y: 0, node: null });
  }, []);

  const closeNodeContextMenu = useCallback(() => {
    setNodeContextMenu({ visible: false, x: 0, y: 0, node: null });
  }, []);

  const closeEdgeMenu = useCallback(() => {
    setEdgeMenu({ visible: false, x: 0, y: 0, edgeId: null });
  }, []);

  // Your click handlers now explicitly close other menus
  const onNodeClick = useCallback((event, node) => {
    event.preventDefault();
    const screenPosition = project({ x: node.position.x + node.width, y: node.position.y + node.height });
    setDeleteButton({
      visible: true,
      x: screenPosition.x,
      y: screenPosition.y,
      node: node,
    });

    closeNodeContextMenu();
    closeEdgeMenu();
  }, [project, closeNodeContextMenu, closeEdgeMenu]);

  const onNodeContextMenu = useCallback((event, node) => {
    event.preventDefault();
    closeDeleteButton();
    closeEdgeMenu();
    setNodeContextMenu({
      visible: true,
      x: event.clientX,
      y: event.clientY,
      node: node,
    });
  }, [closeDeleteButton, closeEdgeMenu]);

  // ... (rest of your component logic)

  // Update handleDeleteNode
  const handleDeleteNode = useCallback((nodeId) => {
    if (nodeId) {
      dispatch(pushStateToHistory());
      dispatch(updateNodes([{ id: nodeId, type: 'remove' }]));
    }
    // No need for explicit close handler call here, as the backdrop will be unmounted
  }, [dispatch]);
  
  // Note: We'll still need to call closeDeleteButton() or closeNodeContextMenu()
  // if you want to close the menu without deleting the item.
  // For example, if you had a 'Cancel' button on the menu.
  // In this new setup, the backdrop will handle closing on outside clicks.
  // We'll keep the close calls inside handleDeleteNode() for good practice.


  return (
    <div style={{ width: "100vw", height: "100vh" }} ref={reactFlowWrapper}>
      {/* ... ReactFlow component ... */}
      
      {/* --- BACKDROP FOR BOTH MENUS --- */}
      {(deleteButton.visible || nodeContextMenu.visible || edgeMenu.visible) && (
        <div
          onClick={() => {
            closeDeleteButton();
            closeNodeContextMenu();
            closeEdgeMenu();
          }}
          style={{
            position: 'absolute',
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
            zIndex: 9999, // IMPORTANT: Should be lower than the menus, but higher than the canvas
          }}
        />
      )}

      {/* --- LEFT-CLICK DELETE BUTTON --- */}
      {deleteButton.visible && deleteButton.node && (
        <button
          onClick={() => handleDeleteNode(deleteButton.node.id)}
          style={{
            ...buttonStyle,
            position: "absolute",
            top: `${deleteButton.y}px`,
            left: `${deleteButton.x}px`,
            backgroundColor: '#e74c3c',
            // IMPORTANT: zIndex must be higher than the backdrop!
            zIndex: 10000, 
            padding: '5px 10px',
            fontSize: '0.8em',
          }}
        >
          Delete Node
        </button>
      )}

      {/* --- RIGHT-CLICK CONTEXT MENU --- */}
      {nodeContextMenu.visible && nodeContextMenu.node && (
        <div
          style={{
            ...menuPanelStyle,
            position: "absolute",
            top: `${nodeContextMenu.y}px`,
            left: `${nodeContextMenu.x}px`,
            // IMPORTANT: zIndex must be higher than the backdrop!
            zIndex: 10000,
          }}
        >
          <strong style={{ display: 'block', marginBottom: '8px' }}>Node Options</strong>
          <button
            onClick={() => handleDeleteNode(nodeContextMenu.node.id)}
            style={{
              ...buttonStyle,
              backgroundColor: '#e74c3c',
              width: "100%",
            }}
          >
            Delete Node
          </button>
          <button
            onClick={() => {
              alert(`Node ${nodeContextMenu.node.id} info...`);
              closeNodeContextMenu();
            }}
            style={{
              ...buttonStyle,
              backgroundColor: '#3498db',
              width: "100%",
              marginTop: '8px',
            }}
          >
            View Info
          </button>
        </div>
      )}

      {/* ... (rest of your JSX) */}
    </div>
  );
};






// In src/ReactFlowWrapper.js

// ... (other imports)

export const ReactFlowWrapper = () => {
  // ... (your existing state and hooks)

  const [nodeContextMenu, setNodeContextMenu] = useState({
    visible: false,
    x: 0,
    y: 0,
    node: null,
  });

  // Let's define the dimensions of your menu. You can get these dynamically or use a fixed size.
  const menuWidth = 150; // The width of your context menu
  const menuHeight = 120; // The approximate height of your context menu

  // ... (your other handlers)

  // --- Handler for right-click (shows a full context menu) ---
  const onNodeContextMenu = useCallback((event, node) => {
    event.preventDefault();

    // Hide the left-click delete button
    setDeleteButton({ visible: false, x: 0, y: 0, node: null });
    
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    let newX = event.clientX;
    let newY = event.clientY;

    // Check if the menu goes off the right edge
    if (event.clientX + menuWidth > viewportWidth) {
      newX = viewportWidth - menuWidth - 10; // Shift left by menu width + a small margin
    }

    // Check if the menu goes off the bottom edge
    if (event.clientY + menuHeight > viewportHeight) {
      newY = viewportHeight - menuHeight - 10; // Shift up by menu height + a small margin
    }
    
    // In case the menu is displayed at the top or left edge
    if(newX < 0) newX = 10;
    if(newY < 0) newY = 10;
    
    // Position the context menu at the adjusted location
    setNodeContextMenu({
      visible: true,
      x: newX,
      y: newY,
      node: node,
    });
  }, []);

  // ... (rest of your component and JSX)
};


